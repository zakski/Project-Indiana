
>From davea@ll-vlsi.ARPA Thu Sep  8 13:29:29 1988
Return-Path: <davea@ll-vlsi.ARPA>
Received: from XN.LL.MIT.EDU (10.2.0.10) by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA24802; Thu, 8 Sep 88 13:28:38 EDT
Received:  from LL-VLSI.ARPA by XN.LL.MIT.EDU; Thu, 8 Sep 88 13:07:57 EDT
Posted-Date: Thu, 8 Sep 88 13:08:05 EDT
Received: by ll-vlsi.arpa (5.51/3.2.sst.ll)
	id AA07748; Thu, 8 Sep 88 13:08:05 EDT
Date: Thu, 8 Sep 88 13:08:05 EDT
From: Dave Allen <davea@ll-vlsi.ARPA>
Message-Id: <8809081708.AA07748@ll-vlsi.arpa>
To: jwm%stdc.jhuapl.edu@XN.LL.MIT.EDU
Subject: Terrels
Cc: davea@ll-vlsi.ARPA
Status: RO

Godd thought about agreeing on some code for representing spheres
for tectonic simulator and climate simulator.  Here's my plan.
The basic idea is to wind up with a 2-D array of terrels, each
of which represents the same amount of surface area.  

Define N as half the height of the array.  Thus, the array will
be 4N elements wide and 2N elements high.  The horizontal row
through the middle of the array is the equator; the top is the
north pole.

Define R as the radius of the sphere, in miles or kms or whatever.
Define D = 2 pi R / 4 N.  This is the length of one terrel at the
equator.  This is really the key concept.  There are 4N terrels
in a line around the equator; 2 pi R is the distance in miles 
around the equator.

We need to find the number of terrels in each horizontal row of
the array.  We know there are 4N terrels in the middle row; that's
the equator.  Here's a code fragment that does this.

for k = 0 to N (distance above the middle row in the array)
  z = R sin (pi k / 2 N) (z is the height above the equatorial plane)
  r = sqrt (R ^ 2 - z ^ 2) (r is the radius of the circle at that height)
  n = pi r / D (n is half the number of terrels in row i) 

Now that we know how many terrels per row, how do we distribute them in
the row of the array?  There are two obvious methods: 1) spread them
evenly across the entire row, or 2) clump them into the middle of the
row.  With (2) the array winds up filled like a 2:1 ellipse; this is
a lot easier to think about, so I tend to go with it.

Moving east-west in this data structure is easy; you just need to
store the n's from the above code fragment so you know when to
wrap around from one side of the array row back to the other.  Moving
north-south is less obvious, and I don't have a good method for it.

Can you think of a good way to keep track of north-south?  Maybe you
have an even better method for representing the surface of a sphere.

Dave

PS I don't know if you want to re-post this; we might get some good
insights from the others.

>From davea@ll-vlsi.ARPA Thu Sep  8 15:17:33 1988
Return-Path: <davea@ll-vlsi.ARPA>
Received: from XN.LL.MIT.EDU (10.2.0.10) by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA25832; Thu, 8 Sep 88 15:16:16 EDT
Received:  from [10.1.0.10] by XN.LL.MIT.EDU; Thu, 8 Sep 88 13:50:07 EDT
Posted-Date: Thu, 8 Sep 88 13:50:18 EDT
Received: by ll-vlsi.arpa (5.51/3.2.sst.ll)
	id AA08087; Thu, 8 Sep 88 13:50:18 EDT
Date: Thu, 8 Sep 88 13:50:18 EDT
From: Dave Allen <davea@ll-vlsi.ARPA>
Message-Id: <8809081750.AA08087@ll-vlsi.arpa>
To: jwm%stdc.jhuapl.edu@XN.LL.MIT.EDU
Subject: Terrels
Cc: davea@ll-vlsi.ARPA
Status: RO

Jim,
Here are some thoughts about moving north / south on a globe.

If we store the n's generated by the previous code fragment we
get an array n[0..N].  If we are at point i,j where i is the vertical
position and j is the horizontal position, we can require 0 < i < N and
2N < j < 4N without loss of generality.  That's a position in the 
northern hemisphere east of the prime meridian, at least the way
I think of it.  We can subtract cleverly to get the other quadrants.

We need two functions, north (i,j) and south (i,j).  North() figures
out what terrel is north of i,j.  We don't have to worry about figuring
out the new i; it's obvious except for flagging the north and south
poles.  The only trick is figuring out the new j; let that be the value
returned by the function.

north (i, j) = 2N + n[i-1] * (j - 2N) / n[i]
south (i, j) = 2N + n[i+1] * (j - 2N) / n[i]

We'd probably compute this once for each array element and store it,
so we'd have two arrays instead of two functions.

Now, this method works, but bad things happen when I think of using it
to move a plate in the tectonic simulator.  A plate moving away from
the equator gets narrower, and one moving towards it gets wider!  The
reason is apparent, but the solution isn't.

That's all for now.
Dave

>From @aplvax.jhuapl.edu:siegel@hc.dspo.gov Thu Sep  8 15:21:45 1988
Return-Path: <@aplvax.jhuapl.edu:siegel@hc.dspo.gov>
Received: from aplvax.jhuapl.edu by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA25877; Thu, 8 Sep 88 15:21:24 EDT
Received: by aplvax.jhuapl.edu (5.51/1.14)
	id AA11342; Thu, 8 Sep 88 15:26:03 EDT
Received: by hc.dspo.gov (5.54/1.14)
	id AA18382; Thu, 8 Sep 88 13:26:01 MDT
Date: Thu, 8 Sep 88 13:26:01 MDT
From: siegel@hc.dspo.gov (josh Siegel)
Message-Id: <8809081926.AA18382@hc.dspo.gov>
X-Mailer: Mail User's Shell (6.3 6/25/88)
To: jwm@aplvax.jhuapl.edu
Subject: FTP account
Status: RO



I will run a ftp site if so desired...

No problem.

Also, what is the email address of the alias?

                --Josh Siegel

>From jwm Thu Sep  8 13:36:21 1988
To: davea@ll-vlsi.ARPA
Subject: Re:  Terrels
Status: RO

>Can you think of a good way to keep track of north-south?  Maybe you
>have an even better method for representing the surface of a sphere.

It sort of depends - for some stuff, just use a sphere!

That is, go ahead and use a spherical coordinate system.  I am thinking that
for some of the stuff I am looking at (winds, temperatures, some
precipitation considerations) continuous functions make more sense.  

Perhaps a continuous world, and discrete segments?

Jim


>From jwm Thu Sep  8 14:23:33 1988
To: aplvax\!uunet.uu.net!\altnet\!altger!\hnt, cthulhu@athena, davea@ll-vlsi.arpa,
    jfc@athena, jl3j@andrew.cmu.edu, jyamato@cory, netxcom!ewiles@uunet.uu.net,
    pearl@aramis.rutgers.edu, therat@ucscb@ucscc.ucsc.edu, wes@umix.cc.umich.edu
Subject: FTP Account
Status: RO

I work in a laboratory.  People would not be thrilled to have an anonymous
ftp account on a computer inside of the laboratory net.  Is there someone
who does not mind keeping the archives for download?  I'll still collect the
stuff, and keep back-up copies.

"Let there be light" (and stars, planets, air, people,...)
jwm@aplvax.jhuapl.edu 128.244.65.5  (James W. Meritt)

>From aplcomm!aplcen!umd5!haven!purdue!mailrus!uwmcsd1!marque!bruces Thu Sep  8 22:18:43 EDT 1988
Status: RO

Article 310 of rec.games.programmer:
Path: aplcomm!aplcen!umd5!haven!purdue!mailrus!uwmcsd1!marque!bruces
>From: bruces@marque.mu.edu (Bruce Stephens)
Newsgroups: rec.games.programmer
Subject: Re: Reversi (really surface generation)
Summary: Buy the $40 book.
Message-ID: <274@marque.mu.edu>
Date: 7 Sep 88 19:30:53 GMT
References: <268@marque.mu.edu> <153@vlsi.ll.mit.edu>
Reply-To: StephensBru%msa.bristol.ac.uk@ukacrl.bitnet
Organization: University of Bristol, UK.
Lines: 74

A quick summary of my algorithm:-

    (I'm working with a 3-D graph plotting routine in GINO - which means
    that I  need  to  work  on a square mesh rather than the usual
    triangular one.)

    1. Define yourself a big enough square array. It ought to be a
    power of 2 + 1 on each side. I tend to use floating point arrays,
    but integers would do.

    2. Set the values at the corners of the array to zero (or
    something).

    3. Repeatedly do :-

        4. Choose the values at the midpoints of the lines in your
        mesh. The basis should be an average of the endpoint heights,
        then you add (random-0.5)*length, where random is a random
        number [0,1) and length is the length of the side that you're
        subdividing.

        5. Choose a value for the centres in your mesh. There are
        several possibilities for this. The one I've used is just to
        choose one direction (x or y) and treat the centre as the
        midpoint of the line between two midpoints (as calculated in
        4).

        6. You now have lots more lines and squares, so do it all
        again on these.

    7. Until you've run out of mesh to subdivide.

    [8. Smooth mesh a little using some method.]

    [9. Create a 'sea' by deciding that p% of the area should be sea.
    Then work out what the actual value should be - call it sl. Then
    set each element of the mesh to max{sl, mesh_value}. This is
    really very effective, but you don't get any 'lakes'.]

    10. Call your favourite isometric plotting routine. (Or write one
    I suppose!)

This is all very well, but it only produces nice looking plots about
half the time. Not very suprisingly, half the time the first centre
you choose will move down - which tends to make most of the surface
invisible, hidden by the edges. So it's better if you fix the centre
in some arbitrary way, which tends to make it sensible to fix all the
values along the edges. Then you can get a nice looking mountain.

There are other ways of producing these sorts of surfaces of course.
You can start with a plane and repeatedly draw random straight lines
on it - moving the plane on one side of the line up or down a bit, for
example. But it tends to take a lot of time to do, much longer than
the simple subdivision. It does allow a mesh of any size though.

Whether or not the smoothing in 9 helps depends a great deal on what
graphics you have available and the details of the surface you get
without it. I found that a simple five-point smoothing (the new centre
value is the average of the old centre value with its 4 neighbours)
was useful on most of the grids, but then I was working with
monochrome simple vector graphics.

I can certainly send anyone the actual program I ended up with - it's
only about 60 lines or so of Fortran (you need GINO though). But it's
probably not worth trying too hard to get in touch with me - the
program is straightforward enough to write.

Details of essentially the same algorithm are in most books on
computer graphics. A really good place to look would be in 'The
science of Fractal Images', but unfortunately that's about $40.

Bruce.
JANET: StephensBru@msa.bristol.ac.uk
Use UKACRL on BITNET from the US. (UKC charges.)


>From ellis@csd4.milw.wisc.edu Thu Sep  8 17:31:00 1988
Return-Path: <ellis@csd4.milw.wisc.edu>
Received: from csd4.milw.wisc.edu (129.89.2.4) by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA26519; Thu, 8 Sep 88 17:30:04 EDT
Received: by csd4.milw.wisc.edu; id AA03366; Thu, 8 Sep 88 14:46:07 CDT
Date: Thu, 8 Sep 88 14:46:07 CDT
From: Thomas J Ellis <ellis@csd4.milw.wisc.edu>
Message-Id: <8809081946.AA03366@csd4.milw.wisc.edu>
To: jwm@stdc.jhuapl.edu
Subject: interest in mailing list
Status: RO

I'm interested in the mailing list for the universe generator.
I have a pascal program that creates a piece of land with different
soil types (rock and dirt), water, and plants. Program simulates
erosion and plant growth. I don't yet have a reasonable weather
generator. The rain is still randomly sprayed over the surface.
Weather is not out of reach, though. It is written in Turbo Pascal
3.0, but doesn't use much beyond standard pascal. Just point
plotting and turning the graphics screen on. I've written it
on an MS-DOS IBM compatible. Please put me on the list. Also,
if you're interested in the program let me know. I think I can
send it to you, I'm new at this.

					Tom Ellis
					


>From siegel@hc.dspo.gov Thu Sep  8 19:17:51 1988
Return-Path: <siegel@hc.dspo.gov>
Received: from hc.dspo.gov (26.1.0.90) by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA26565; Thu, 8 Sep 88 19:17:42 EDT
Received: by hc.dspo.gov (5.54/1.14)
	id AA22223; Thu, 8 Sep 88 17:22:56 MDT
Date: Thu, 8 Sep 88 17:22:56 MDT
From: siegel@hc.dspo.gov (josh Siegel)
Message-Id: <8809082322.AA22223@hc.dspo.gov>
To: jwm@stdc.jhuapl.edu
Subject: Ftp archive
Status: RO


% ftp hc.dspo.gov
% ftp 192.12.184.4
% ftp dspo.dspo.gov

Anyhow, it is in the pub/usml directory.

          --Josh

>From @aplvax.jhuapl.edu:awksnsr@titan.nmt.edu Thu Sep  8 23:53:21 1988
Return-Path: <@aplvax.jhuapl.edu:awksnsr@titan.nmt.edu>
Received: from aplvax.jhuapl.edu by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA27108; Thu, 8 Sep 88 23:53:05 EDT
Received: by aplvax.jhuapl.edu (5.51/1.14)
	id AA15365; Thu, 8 Sep 88 23:53:56 EDT
Received: from titan.nmt.edu by nmt.edu (3.2/NMT-0.3MH)
	       id AA15640; Thu, 8 Sep 88 08:53:47 MDT
Received: by titan.nmt.edu (3.2/NMT-0.3C)
	       id AA23008; Thu, 8 Sep 88 08:53:42 MDT
Date: Thu, 8 Sep 88 08:53:42 MDT
From: awksnsr@titan.nmt.edu
Message-Id: <8809081453.AA23008@titan.nmt.edu>
To: jwm@stdc.jhuapl.edu
Subject: Re: Universe Simulator
Newsgroups: rec.games.frp,rec.games.programmer
In-Reply-To: <1811@aplcomm.jhuapl.edu>
Organization: New Mexico Tech, Socorro NM
Status: RO

===
I'm also interested in the universe simulator and algorithms.
I also noticed that Clifford Adams (also at NMT) was on your list of
people that you couldn't reply to.  If you can't get through to me, I'll
get together with our 'net specialists' and see what's wrong.

Thanks.


-- 
Alan W. Kerr   --The Mad Scotsman     awksnsr@nmtsun.nmt.edu
New Mexico Tech                       awksnsr%nmt@relay.cs.net
Socorro, NM, USA                      cmcl2!lanl!unm-la!unmvax!nmtsun!awksnsr

>From siegel@hc.dspo.gov Thu Sep  8 19:17:51 1988
Return-Path: <siegel@hc.dspo.gov>
Received: from hc.dspo.gov (26.1.0.90) by stdc.jhuapl.edu (3.2/SMI-3.2)
	id AA26565; Thu, 8 Sep 88 19:17:42 EDT
Received: by hc.dspo.gov (5.54/1.14)
	id AA22223; Thu, 8 Sep 88 17:22:56 MDT
Date: Thu, 8 Sep 88 17:22:56 MDT
From: siegel@hc.dspo.gov (josh Siegel)
Message-Id: <8809082322.AA22223@hc.dspo.gov>
To: jwm@stdc.jhuapl.edu
Subject: Ftp archive
Status: RO

Josh Siegel has established an anonymous ftp account for our archives at:


% ftp hc.dspo.gov
% ftp 192.12.184.4
% ftp dspo.dspo.gov

Anyhow, it is in the pub/usml directory.

   It contains:

-rw-rw-r--  1 root     wheel       41639 Sep  8 17:17 OtherSun.src
-rw-rw-r--  1 root     wheel        5334 Sep  8 17:17 fractal.c
-rw-rw-r--  1 root     wheel       60385 Sep  8 17:18 system.arc
-rw-rw-r--  1 root     wheel       28499 Sep  8 17:18 traveller.src
-rw-rw-r--  1 root     wheel       28241 Sep  8 17:21 universe1
-rw-rw-r--  1 root     wheel       38380 Sep  8 17:21 universe2
-rw-rw-r--  1 root     wheel       27108 Sep  8 17:19 universe3
-rw-rw-r--  1 root     wheel       58656 Sep  8 17:19 universe4
-rw-rw-r--  1 root     wheel       19669 Sep  8 17:19 universe5
-rw-rw-r--  1 root     wheel       17853 Sep  8 17:20 universe6
-rw-rw-r--  1 root     wheel       28485 Sep  8 17:20 universe7
-rw-rw-r--  1 root     wheel       26256 Sep  8 17:20 universe8
-rw-rw-r--  1 root     wheel       28505 Sep  8 17:21 universe9

The first 4 are source code for random system generation routines and fractal
landscapes.  The 9 universe files are past messages, rec.games.frp/programmer
articles relevant,.....

Thanks, Josh!

"Let there be light" (and stars, planets, air, people,...)
jwm@aplvax.jhuapl.edu 128.244.65.5  (James W. Meritt)



                                                                                                                